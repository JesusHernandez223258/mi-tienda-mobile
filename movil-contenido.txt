╭─░▒▓ ~/AndroidStudioProjects/MobileShop  feature-correction +29 !111 ?3               ✔  08:06:10 ▓▒░
╰─ tree app/src/main/java/com/mobileshop/
app/src/main/java/com/mobileshop/
├── core
│   ├── common
│   │   └── ConnectivityObserver.kt
│   ├── data
│   │   ├── camera
│   │   │   └── CameraManagerImpl.kt
│   │   ├── local
│   │   │   ├── AppDatabase.kt
│   │   │   └── TokenManager.kt
│   │   └── remote
│   │       ├── ApiService.kt
│   │       ├── AuthInterceptor.kt
│   │       ├── dto
│   │       │   ├── ApiResponse.kt
│   │       │   ├── GetProductsResponse.kt
│   │       │   ├── ProductDto.kt
│   │       │   └── SyncDtos.kt
│   │       └── TokenAuthenticator.kt
│   ├── di
│   │   ├── DatabaseModule.kt
│   │   ├── DataStoreModule.kt
│   │   ├── HardwareModule.kt
│   │   ├── NetworkModule.kt
│   │   └── RepositoryModule.kt
│   └── domain
│       └── camera
│           ├── CameraManager.kt
│           └── UseCases.kt
├── features
│   ├── auth
│   │   ├── data
│   │   │   ├── remote
│   │   │   │   └── dto
│   │   │   │       ├── LoginRequest.kt
│   │   │   │       ├── LoginResponse.kt
│   │   │   │       └── RegisterRequest.kt
│   │   │   └── repository
│   │   │       └── AuthRepositoryImpl.kt
│   │   ├── domain
│   │   │   ├── model
│   │   │   ├── repository
│   │   │   │   └── AuthRepository.kt
│   │   │   └── use_case
│   │   │       ├── LoginUseCase.kt
│   │   │       ├── LogoutUseCase.kt
│   │   │       └── RegisterUseCase.kt
│   │   └── presentation
│   │       ├── login
│   │       │   ├── LoginScreen.kt
│   │       │   └── LoginViewModel.kt
│   │       └── register
│   │           ├── RegisterScreen.kt
│   │           └── RegisterViewModel.kt
│   ├── products
│   │   ├── data
│   │   │   ├── local
│   │   │   │   ├── ProductDao.kt
│   │   │   │   └── ProductEntity.kt
│   │   │   ├── mapper
│   │   │   │   └── ProductMapper.kt
│   │   │   ├── remote
│   │   │   │   └── dto
│   │   │   │       └── CreateProductRequest.kt
│   │   │   └── repository
│   │   │       └── ProductRepositoryImpl.kt
│   │   ├── domain
│   │   │   ├── model
│   │   │   │   └── Product.kt
│   │   │   ├── repository
│   │   │   │   └── ProductRepository.kt
│   │   │   └── use_case
│   │   │       ├── CreateProductUseCase.kt
│   │   │       ├── DeleteProductUseCase.kt
│   │   │       ├── GetProductByIdUseCase.kt
│   │   │       ├── GetProductsUseCase.kt
│   │   │       └── UpdateProductUseCase.kt
│   │   └── presentation
│   │       ├── AddProductScreen.kt
│   │       ├── ProductDetailScreen.kt
│   │       ├── ProductDetailState.kt
│   │       ├── ProductDetailViewModel.kt
│   │       ├── ProductsScreen.kt
│   │       ├── ProductsState.kt
│   │       └── ProductsViewModel.kt
│   └── sync
│       ├── data
│       │   └── repository
│       │       └── SyncRepositoryImpl.kt
│       ├── domain
│       │   ├── repository
│       │   │   └── SyncRepository.kt
│       │   └── use_case
│       │       └── SyncDataUseCase.kt
│       └── presentation
│           └── service
│               └── SyncService.kt
├── MainActivity.kt
├── MyApplication.kt
├── navigation
│   ├── Navigation.kt
│   ├── SplashScreen.kt
│   └── SplashViewModel.kt
└── ui
    └── theme
        ├── Color.kt
        ├── Theme.kt
        └── Type.kt

47 directories, 61 files


===== ./app/src/main/java/com/mobileshop/core/common/ConnectivityObserver.kt =====
package com.mobileshop.core.common

import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.distinctUntilChanged
import javax.inject.Inject

class ConnectivityObserver @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val connectivityManager =
        context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

    fun observe(): Flow<Status> {
        return callbackFlow {
            val callback = object : ConnectivityManager.NetworkCallback() {
                override fun onAvailable(network: Network) {
                    super.onAvailable(network)
                    trySend(Status.Available)
                }

                override fun onLosing(network: Network, maxMsToLive: Int) {
                    super.onLosing(network, maxMsToLive)
                    trySend(Status.Losing)
                }

                override fun onLost(network: Network) {
                    super.onLost(network)
                    trySend(Status.Lost)
                }

                override fun onUnavailable() {
                    super.onUnavailable()
                    trySend(Status.Unavailable)
                }
            }

            connectivityManager.registerDefaultNetworkCallback(callback)
            awaitClose {
                connectivityManager.unregisterNetworkCallback(callback)
            }
        }.distinctUntilChanged()
    }

    enum class Status {
        Available, Unavailable, Losing, Lost
    }
}
===== ./app/src/main/java/com/mobileshop/core/data/camera/CameraManagerImpl.kt =====
// EN: app/src/main/java/com/mobileshop/core/data/camera/CameraManagerImpl.kt
package com.mobileshop.core.data.camera

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.net.Uri
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import com.mobileshop.BuildConfig
import com.mobileshop.core.domain.camera.CameraManager
import java.io.File
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class CameraManagerImpl @Inject constructor() : CameraManager { // Ya no necesita el contexto en el constructor

    override fun hasCameraPermission(context: Context): Boolean {
        return ContextCompat.checkSelfPermission(
            context, Manifest.permission.CAMERA
        ) == PackageManager.PERMISSION_GRANTED
    }

    override fun createImageUri(context: Context): Uri {
        val file = File.createTempFile("camera_photo_", ".jpg", context.cacheDir)
        return FileProvider.getUriForFile(
            context,
            "${BuildConfig.APPLICATION_ID}.provider",
            file
        )
    }
}
===== ./app/src/main/java/com/mobileshop/core/data/local/AppDatabase.kt =====
package com.mobileshop.core.data.local

import androidx.room.Database
import androidx.room.RoomDatabase
import com.mobileshop.features.products.data.local.ProductDao
import com.mobileshop.features.products.data.local.ProductEntity

@Database(entities = [ProductEntity::class], version = 1, exportSchema = false)
abstract class AppDatabase : RoomDatabase() {
    abstract fun productDao(): ProductDao
}
===== ./app/src/main/java/com/mobileshop/core/data/local/TokenManager.kt =====
package com.mobileshop.core.data.local

import android.content.Context
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKeys
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton
import androidx.core.content.edit

@Singleton
class TokenManager @Inject constructor(@ApplicationContext context: Context) {

    private val masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)
    private val prefsName = "secure_user_prefs"

    private val sharedPreferences = EncryptedSharedPreferences.create(
        prefsName,
        masterKeyAlias,
        context,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )

    companion object {
        private const val ACCESS_TOKEN_KEY = "access_token"
        private const val REFRESH_TOKEN_KEY = "refresh_token"
        private const val LAST_SYNC_TIMESTAMP_KEY = "last_sync_timestamp"
    }

    fun saveTokens(accessToken: String, refreshToken: String) {
        sharedPreferences.edit {
            putString(ACCESS_TOKEN_KEY, accessToken)
                .putString(REFRESH_TOKEN_KEY, refreshToken)
        }
    }

    fun getAccessToken(): String? = sharedPreferences.getString(ACCESS_TOKEN_KEY, null)
    fun getRefreshToken(): String? = sharedPreferences.getString(REFRESH_TOKEN_KEY, null)

    fun clearTokens() {
        sharedPreferences.edit {
            remove(ACCESS_TOKEN_KEY)
                .remove(REFRESH_TOKEN_KEY)
        }
    }

    fun saveLastSyncTimestamp(timestamp: Long) {
        sharedPreferences.edit { putLong(LAST_SYNC_TIMESTAMP_KEY, timestamp) }
    }

    fun getLastSyncTimestamp(): Long = sharedPreferences.getLong(LAST_SYNC_TIMESTAMP_KEY, 0L)
}
===== ./app/src/main/java/com/mobileshop/core/data/remote/ApiService.kt =====
package com.mobileshop.core.data.remote

import com.mobileshop.core.data.remote.dto.ApiResponse
import com.mobileshop.core.data.remote.dto.GetProductsResponse
import com.mobileshop.core.data.remote.dto.ProductDto
import com.mobileshop.core.data.remote.dto.SyncRequest
import com.mobileshop.core.data.remote.dto.SyncResponseDto
import com.mobileshop.features.auth.data.remote.dto.LoginRequest
import com.mobileshop.features.auth.data.remote.dto.LoginResponse
import com.mobileshop.features.auth.data.remote.dto.RefreshResponse
import com.mobileshop.features.auth.data.remote.dto.RegisterRequest
import okhttp3.MultipartBody
import okhttp3.RequestBody
import retrofit2.http.Multipart
import retrofit2.http.Part
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.DELETE
import retrofit2.http.GET
import retrofit2.http.POST
import retrofit2.http.PUT
import retrofit2.http.Path

interface ApiService {

    // --- Auth ---
    @POST("auth/login")
    suspend fun login(@Body request: LoginRequest): Response<ApiResponse<LoginResponse>>

    @POST("auth/register")
    suspend fun register(@Body request: RegisterRequest): Response<Unit>

    @POST("auth/refresh")
    suspend fun refreshToken(@Body body: Map<String, String>): Response<ApiResponse<RefreshResponse>>

    // --- Products ---
    @GET("productos")
    suspend fun getProducts(): ApiResponse<GetProductsResponse>

    @GET("productos/{id}")
    suspend fun getProductById(@Path("id") id: String): ApiResponse<ProductDto>

    @Multipart
    @PUT("productos/{id}")
    suspend fun updateProduct(
        @Path("id") id: String,
        @Part("nombre") nombre: RequestBody,
        @Part("descripcion") descripcion: RequestBody,
        @Part("precio") precio: RequestBody,
        @Part("stock") stock: RequestBody,
        @Part imagen: MultipartBody.Part?
    ): ApiResponse<ProductDto>

    @DELETE("productos/{id}")
    suspend fun deleteProduct(@Path("id") id: String): Response<Unit>

    @Multipart
    @POST("productos")
    suspend fun createProduct(
        @Part("nombre") nombre: RequestBody,
        @Part("descripcion") descripcion: RequestBody,
        @Part("precio") precio: RequestBody,
        @Part("stock") stock: RequestBody,
        @Part imagen: MultipartBody.Part?
    ): ApiResponse<ProductDto>

    @GET("productos/all-for-sync")
    suspend fun getAllProductsForSync(): ApiResponse<List<ProductDto>>

    @POST("productos/sync")
    suspend fun syncProducts(@Body request: SyncRequest): Response<ApiResponse<SyncResponseDto>>
}
===== ./app/src/main/java/com/mobileshop/core/data/remote/AuthInterceptor.kt =====
package com.mobileshop.core.data.remote

import com.mobileshop.core.data.local.TokenManager
import okhttp3.Interceptor
import okhttp3.Response
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class AuthInterceptor @Inject constructor(
    private val tokenManager: TokenManager
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        // CORRECCIÓN: Llamada síncrona directa, sin runBlocking
        val token: String? = tokenManager.getAccessToken()

        val requestBuilder = chain.request().newBuilder()
        if (!token.isNullOrEmpty()) {
            requestBuilder.addHeader("Authorization", "Bearer $token")
        }

        return chain.proceed(requestBuilder.build())
    }
}
===== ./app/src/main/java/com/mobileshop/core/data/remote/dto/ApiResponse.kt =====
package com.mobileshop.core.data.remote.dto

// Un DTO genérico para las respuestas de la API
data class ApiResponse<T>(
    val status: String,
    val message: String,
    val data: T
)
===== ./app/src/main/java/com/mobileshop/core/data/remote/dto/GetProductsResponse.kt =====
package com.mobileshop.core.data.remote.dto

data class GetProductsResponse(
    val products: List<ProductDto>
    // Puedes añadir aquí totalPages, etc., si los necesitas en el futuro
)
===== ./app/src/main/java/com/mobileshop/core/data/remote/dto/ProductDto.kt =====
package com.mobileshop.core.data.remote.dto

import com.google.gson.annotations.SerializedName

data class ProductDto(
    @SerializedName("_id")
    val id: String,
    val nombre: String,
    val descripcion: String,
    val precio: Double,
    val stock: Int,
    val imagenUrl: String?
)
===== ./app/src/main/java/com/mobileshop/core/data/remote/dto/SyncDtos.kt =====
package com.mobileshop.core.data.remote.dto

/**
 * DTO for sending a single product in sync request
 */
data class ProductSyncDto(
    val tempId: String,
    val nombre: String,
    val descripcion: String,
    val precio: Double,
    val stock: Int
)

/**
 * Wrapper for sync request body
 */
data class SyncRequest(
    val products: List<ProductSyncDto>
)

/**
 * DTO for a single sync result item
 */
data class SyncResultItemDto(
    val tempId: String?,
    val success: Boolean,
    val errorMessage: String? = null
)

/**
 * Data returned by the /sync endpoint
 */
data class SyncResponseDto(
    val data: SyncResultDto
)

/**
 * DTO wrapping successful and failed sync lists
 */
data class SyncResultDto(
    val successful: List<SyncResultItemDto>,
    val failed: List<SyncResultItemDto>
)
===== ./app/src/main/java/com/mobileshop/core/data/remote/TokenAuthenticator.kt =====
package com.mobileshop.core.data.remote

import com.mobileshop.core.data.local.TokenManager
import kotlinx.coroutines.runBlocking
import okhttp3.Authenticator
import okhttp3.Request
import okhttp3.Response
import okhttp3.Route
import javax.inject.Inject

class TokenAuthenticator @Inject constructor(
    private val tokenManager: TokenManager,
    private val apiService: dagger.Lazy<ApiService> // Usamos Lazy para evitar inyección cíclica
) : Authenticator {

    override fun authenticate(route: Route?, response: Response): Request? {
        val currentToken = tokenManager.getAccessToken()
        // Si la petición que falló ya usaba el token actual, no reintentamos
        if (response.request.header("Authorization")?.endsWith(currentToken ?: "") == false) {
            return null
        }

        synchronized(this) {
            val newAccessToken = runBlocking {
                getNewToken()
            }

            return if (newAccessToken != null) {
                response.request.newBuilder()
                    .header("Authorization", "Bearer $newAccessToken")
                    .build()
            } else {
                // Si no se pudo refrescar, no reintentamos (se requerirá login)
                null
            }
        }
    }

    private suspend fun getNewToken(): String? {
        val refreshToken = tokenManager.getRefreshToken() ?: return null

        return try {
            val refreshResponse = apiService.get().refreshToken(mapOf("refreshToken" to refreshToken))

            if (refreshResponse.isSuccessful && refreshResponse.body() != null) {
                val newAccessToken = refreshResponse.body()!!.data.accessToken
                tokenManager.saveTokens(newAccessToken, refreshToken) // Guardamos el nuevo access token con el refresh token viejo
                newAccessToken
            } else {
                // El refresh token es inválido, limpiamos todo
                tokenManager.clearTokens()
                null
            }
        } catch (e: Exception) {
            tokenManager.clearTokens()
            null
        }
    }
}
===== ./app/src/main/java/com/mobileshop/core/di/DatabaseModule.kt =====
package com.mobileshop.core.di

import android.content.Context
import androidx.room.Room
import com.mobileshop.core.data.local.AppDatabase
import com.mobileshop.features.products.data.local.ProductDao
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Provides
    @Singleton
    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "mobileshop_db"
        ).build()
    }

    @Provides
    @Singleton
    fun provideProductDao(database: AppDatabase): ProductDao {
        return database.productDao()
    }
}
===== ./app/src/main/java/com/mobileshop/core/di/DataStoreModule.kt =====
package com.mobileshop.core.di

import android.content.Context
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.preferencesDataStore
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

private val Context.dataStore by preferencesDataStore(name = "user_prefs")

@Module
@InstallIn(SingletonComponent::class)
object DataStoreModule {

    @Provides
    @Singleton
    fun provideDataStore(@ApplicationContext context: Context): DataStore<Preferences> {
        return context.dataStore
    }
}
===== ./app/src/main/java/com/mobileshop/core/di/HardwareModule.kt =====
// EN: app/src/main/java/com/mobileshop/core/di/HardwareModule.kt
package com.mobileshop.core.di

//import com.mobileshop.core.data.biometric.BiometricAuthenticatorImpl
import com.mobileshop.core.data.camera.CameraManagerImpl // <-- IMPORTAR
//import com.mobileshop.core.domain.biometric.BiometricAuthenticator
import com.mobileshop.core.domain.camera.CameraManager // <-- IMPORTAR
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
abstract class HardwareModule {

    // --- AÑADIR ESTO ---
    @Binds
    @Singleton
    abstract fun bindCameraManager(
        impl: CameraManagerImpl
    ): CameraManager
    // ---------------------
}
===== ./app/src/main/java/com/mobileshop/core/di/NetworkModule.kt =====
package com.mobileshop.core.di

import com.mobileshop.core.data.remote.ApiService
import com.mobileshop.core.data.remote.AuthInterceptor
import com.mobileshop.core.data.remote.TokenAuthenticator
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    @Provides
    @Singleton
    fun provideOkHttpClient(authInterceptor: AuthInterceptor, tokenAuthenticator: TokenAuthenticator): OkHttpClient { // Inyectamos el Authenticator
        return OkHttpClient.Builder()
            .addInterceptor(authInterceptor)
            .authenticator(tokenAuthenticator) // <-- AÑADIMOS EL AUTHENTICATOR
            .addInterceptor(HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY))
            .build()
    }

    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            // local
            .baseUrl("http://10.0.2.2:3000/api/v1/")
            // Datos
            //.baseUrl("https://mi-tienda-mobile-api.onrender.com/api/v1/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }

    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
===== ./app/src/main/java/com/mobileshop/core/di/RepositoryModule.kt =====
package com.mobileshop.core.di

import com.mobileshop.features.auth.data.repository.AuthRepositoryImpl
import com.mobileshop.features.auth.domain.repository.AuthRepository
import com.mobileshop.features.products.data.repository.ProductRepositoryImpl
import com.mobileshop.features.products.domain.repository.ProductRepository
import com.mobileshop.features.sync.data.repository.SyncRepositoryImpl // <-- AÑADIR ESTE IMPORT
import com.mobileshop.features.sync.domain.repository.SyncRepository // <-- AÑADIR ESTE IMPORT
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {

    @Binds
    @Singleton
    abstract fun bindAuthRepository(impl: AuthRepositoryImpl): AuthRepository

    @Binds
    @Singleton
    abstract fun bindProductRepository(impl: ProductRepositoryImpl): ProductRepository

    // --- ✅ AÑADE ESTE BLOQUE PARA SOLUCIONAR EL ERROR ---
    @Binds
    @Singleton
    abstract fun bindSyncRepository(impl: SyncRepositoryImpl): SyncRepository
    // ----------------------------------------------------
}
===== ./app/src/main/java/com/mobileshop/core/domain/camera/CameraManager.kt =====
// EN: app/src/main/java/com/mobileshop/core/domain/camera/CameraManager.kt
package com.mobileshop.core.domain.camera

import android.content.Context
import android.net.Uri

// Elimina la clase sellada 'CameraCaptureResult' por ahora para simplificar.
// La mantendremos en mente para futuras mejoras.

interface CameraManager {
    /**
     * Comprueba si el permiso de la cámara ha sido concedido.
     * @return 'true' si el permiso está concedido, 'false' en caso contrario.
     */
    fun hasCameraPermission(context: Context): Boolean // Pasaremos el contexto desde la UI

    /**
     * Crea una URI temporal para almacenar la foto capturada.
     * @return La [Uri] del archivo temporal.
     */
    fun createImageUri(context: Context): Uri // Pasaremos el contexto desde la UI
}
===== ./app/src/main/java/com/mobileshop/core/domain/camera/UseCases.kt =====
package com.mobileshop.core.domain.camera


===== ./app/src/main/java/com/mobileshop/features/auth/data/remote/dto/LoginRequest.kt =====
package com.mobileshop.features.auth.data.remote.dto

data class LoginRequest(
    val email: String,
    val password: String
)
===== ./app/src/main/java/com/mobileshop/features/auth/data/remote/dto/LoginResponse.kt =====
package com.mobileshop.features.auth.data.remote.dto

// DTO para la respuesta de /login
data class LoginResponse(
    val accessToken: String,
    val refreshToken: String,
    val user: UserDto
)

// DTO para el objeto de usuario anidado
data class UserDto(
    val id: String,
    val email: String,
    val role: String
)

// DTO para la respuesta de /refresh
data class RefreshResponse(
    val accessToken: String
)
===== ./app/src/main/java/com/mobileshop/features/auth/data/remote/dto/RegisterRequest.kt =====
package com.mobileshop.features.auth.data.remote.dto

data class RegisterRequest(
    val email: String,
    val password: String,
    val role: String
)
===== ./app/src/main/java/com/mobileshop/features/auth/data/repository/AuthRepositoryImpl.kt =====
package com.mobileshop.features.auth.data.repository

import com.mobileshop.core.data.local.TokenManager
import com.mobileshop.core.data.remote.ApiService
import com.mobileshop.features.auth.data.remote.dto.LoginRequest
import com.mobileshop.features.auth.data.remote.dto.RegisterRequest
import com.mobileshop.features.auth.domain.repository.AuthRepository
import javax.inject.Inject

// Asegúrate de que la clase NO sea abstracta
class AuthRepositoryImpl @Inject constructor(
    private val apiService: ApiService,
    private val tokenManager: TokenManager // Inyectamos TokenManager
) : AuthRepository {

    override suspend fun login(loginRequest: LoginRequest): Result<Unit> { // <-- Devuelve Unit
        return try {
            val response = apiService.login(loginRequest)
            if (response.isSuccessful && response.body() != null) {
                val data = response.body()!!.data
                // ✅ CORRECTO: Guardamos ambos tokens
                tokenManager.saveTokens(data.accessToken, data.refreshToken)
                Result.success(Unit) // <-- Devolvemos éxito sin datos extra
            } else {
                val errorMsg = response.errorBody()?.string() ?: "Error en login"
                Result.failure(Exception(errorMsg))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    override suspend fun register(registerRequest: RegisterRequest): Result<Unit> {
        return try {
            val response = apiService.register(registerRequest)
            if (response.isSuccessful) {
                Result.success(Unit)
            } else {
                val errorMsg = response.errorBody()?.string() ?: "Error en el registro: ${response.code()}"
                Result.failure(Exception(errorMsg))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

===== ./app/src/main/java/com/mobileshop/features/auth/domain/repository/AuthRepository.kt =====
package com.mobileshop.features.auth.domain.repository

import com.mobileshop.features.auth.data.remote.dto.LoginRequest
import com.mobileshop.features.auth.data.remote.dto.RegisterRequest

interface AuthRepository {
    suspend fun login(loginRequest: LoginRequest): Result<Unit>
    suspend fun register(registerRequest: RegisterRequest): Result<Unit>
}
===== ./app/src/main/java/com/mobileshop/features/auth/domain/use_case/LoginUseCase.kt =====
package com.mobileshop.features.auth.domain.use_case

import com.mobileshop.features.auth.data.remote.dto.LoginRequest
import com.mobileshop.features.auth.domain.repository.AuthRepository
import javax.inject.Inject

class LoginUseCase @Inject constructor(private val repository: AuthRepository) {
    // CAMBIO: La firma ahora devuelve Result<Unit>
    suspend operator fun invoke(loginRequest: LoginRequest): Result<Unit> = repository.login(loginRequest)
}
===== ./app/src/main/java/com/mobileshop/features/auth/domain/use_case/LogoutUseCase.kt =====
package com.mobileshop.features.auth.domain.use_case

import com.mobileshop.core.data.local.TokenManager
import javax.inject.Inject

class LogoutUseCase @Inject constructor(
    private val tokenManager: TokenManager
) {
    suspend operator fun invoke() {
        tokenManager.clearTokens()
    }
}
===== ./app/src/main/java/com/mobileshop/features/auth/domain/use_case/RegisterUseCase.kt =====
package com.mobileshop.features.auth.domain.use_case

import com.mobileshop.features.auth.data.remote.dto.RegisterRequest
import com.mobileshop.features.auth.domain.repository.AuthRepository
import javax.inject.Inject

class RegisterUseCase @Inject constructor(private val repository: AuthRepository) {
    suspend operator fun invoke(registerRequest: RegisterRequest) = repository.register(registerRequest)
}
===== ./app/src/main/java/com/mobileshop/features/auth/presentation/login/LoginScreen.kt =====
package com.mobileshop.features.auth.presentation.login

import android.widget.Toast
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Email
import androidx.compose.material.icons.outlined.Lock
import androidx.compose.material.icons.outlined.Visibility
import androidx.compose.material.icons.outlined.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel

@Composable
fun LoginScreen(
    viewModel: LoginViewModel = hiltViewModel(),
    onLoginSuccess: () -> Unit,
    onNavigateToRegister: () -> Unit
) {
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var passwordVisible by remember { mutableStateOf(false) } // Para mostrar/ocultar contraseña
    val loginState by viewModel.loginState.observeAsState()
    val context = LocalContext.current

    LaunchedEffect(key1 = loginState) {
        when (val state = loginState) {
            is LoginState.Success -> {
                Toast.makeText(context, "Login exitoso", Toast.LENGTH_SHORT).show()
                onLoginSuccess()
            }
            is LoginState.Error -> {
                Toast.makeText(context, "Error: ${state.message}", Toast.LENGTH_LONG).show()
            }
            else -> Unit
        }
    }

    // Usamos un Box para centrar todo el contenido en la pantalla
    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        contentAlignment = Alignment.Center
    ) {
        // El Card agrupa visualmente el formulario
        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)
        ) {
            Column(
                modifier = Modifier.padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                // 1. Título con mayor jerarquía
                Text(
                    text = "Bienvenido, Admin",
                    style = MaterialTheme.typography.headlineMedium
                )
                Text(
                    text = "Inicia sesión para continuar",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                Spacer(modifier = Modifier.height(24.dp))

                // 2. Campo de email mejorado
                OutlinedTextField(
                    value = email,
                    onValueChange = { email = it },
                    label = { Text("Correo electrónico") },
                    modifier = Modifier.fillMaxWidth(),
                    leadingIcon = {
                        Icon(Icons.Outlined.Email, contentDescription = "Email Icon")
                    },
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
                    singleLine = true
                )

                Spacer(modifier = Modifier.height(16.dp))

                // 3. Campo de contraseña mejorado con visibilidad
                OutlinedTextField(
                    value = password,
                    onValueChange = { password = it },
                    label = { Text("Contraseña") },
                    modifier = Modifier.fillMaxWidth(),
                    leadingIcon = {
                        Icon(Icons.Outlined.Lock, contentDescription = "Password Icon")
                    },
                    trailingIcon = {
                        val image = if (passwordVisible) Icons.Outlined.VisibilityOff else Icons.Outlined.Visibility
                        IconButton(onClick = { passwordVisible = !passwordVisible }) {
                            Icon(image, "Toggle visibility")
                        }
                    },
                    visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
                    singleLine = true
                )

                Spacer(modifier = Modifier.height(24.dp))

                // 4. Botón principal con más presencia
                Button(
                    onClick = { viewModel.onLoginClicked(email, password) },
                    enabled = loginState !is LoginState.Loading,
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(50.dp)
                ) {
                    Text("INICIAR SESIÓN")
                }

                if (loginState is LoginState.Loading) {
                    Spacer(modifier = Modifier.height(16.dp))
                    CircularProgressIndicator()
                }

                Spacer(modifier = Modifier.height(16.dp))

                // 5. Enlace a registro, más sutil
                TextButton(onClick = onNavigateToRegister, modifier = Modifier.padding(top = 8.dp)) {
                    Text("Registrar nuevo administrador")
                }
            }
        }
    }
}
===== ./app/src/main/java/com/mobileshop/features/auth/presentation/login/LoginViewModel.kt =====
package com.mobileshop.features.auth.presentation.login

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.mobileshop.core.data.local.TokenManager // <-- ¡IMPORTANTE!
import com.mobileshop.features.auth.data.remote.dto.LoginRequest
import com.mobileshop.features.auth.domain.use_case.LoginUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class LoginViewModel @Inject constructor(
    private val loginUseCase: LoginUseCase
) : ViewModel() {

    private val _loginState = MutableLiveData<LoginState>()
    val loginState: LiveData<LoginState> = _loginState

    fun onLoginClicked(email: String, pass: String) {
        viewModelScope.launch {
            _loginState.value = LoginState.Loading
            loginUseCase(LoginRequest(email, pass))
                .onSuccess {
                    _loginState.value = LoginState.Success
                }
                .onFailure {
                    _loginState.value = LoginState.Error(it.message ?: "Error desconocido")
                }
        }
    }
}

sealed class LoginState {
    object Loading : LoginState()
    object Success : LoginState()
    data class Error(val message: String) : LoginState()
}
===== ./app/src/main/java/com/mobileshop/features/auth/presentation/register/RegisterScreen.kt =====
package com.mobileshop.features.auth.presentation.register

import android.widget.Toast
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Email
import androidx.compose.material.icons.outlined.Lock
import androidx.compose.material.icons.outlined.VpnKey
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import kotlinx.coroutines.flow.collectLatest

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun RegisterScreen(
    viewModel: RegisterViewModel = hiltViewModel(),
    onRegisterSuccess: () -> Unit,
    onNavigateBack: () -> Unit // Lambda para volver atrás
) {
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    val context = LocalContext.current
    val registerState by viewModel.registerState.collectAsState()

    LaunchedEffect(key1 = true) {
        viewModel.eventFlow.collectLatest { event ->
            when (event) {
                is RegisterEvent.Success -> {
                    Toast.makeText(context, event.message, Toast.LENGTH_LONG).show()
                    onRegisterSuccess()
                }
                is RegisterEvent.Error -> {
                    Toast.makeText(context, "Error: ${event.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Registro de Administrador") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        // ✅ CORRECCIÓN: Usamos el icono AutoMirrored
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Volver")
                    }
                }
            )
        }
    ) { padding ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            contentAlignment = Alignment.Center
        ) {
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)
            ) {
                Column(
                    modifier = Modifier.padding(24.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "Crear Cuenta",
                        style = MaterialTheme.typography.headlineMedium
                    )
                    Text(
                        text = "Completa los datos para el nuevo admin",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )

                    Spacer(modifier = Modifier.height(24.dp))

                    OutlinedTextField(
                        value = email,
                        onValueChange = { email = it },
                        label = { Text("Correo electrónico") },
                        modifier = Modifier.fillMaxWidth(),
                        leadingIcon = { Icon(Icons.Outlined.Email, "Email") },
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
                        singleLine = true
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    OutlinedTextField(
                        value = password,
                        onValueChange = { password = it },
                        label = { Text("Contraseña") },
                        modifier = Modifier.fillMaxWidth(),
                        leadingIcon = { Icon(Icons.Outlined.Lock, "Password") },
                        visualTransformation = PasswordVisualTransformation(),
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
                        singleLine = true
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    Button(
                        onClick = {
                            viewModel.onRegisterClicked(email, password)
                        },
                        enabled = !registerState.isLoading,
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(50.dp)
                    ) {
                        Text("REGISTRAR")
                    }

                    if (registerState.isLoading) {
                        Spacer(modifier = Modifier.height(16.dp))
                        CircularProgressIndicator()
                    }
                }
            }
        }
    }
}
===== ./app/src/main/java/com/mobileshop/features/auth/presentation/register/RegisterViewModel.kt =====
package com.mobileshop.features.auth.presentation.register

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.mobileshop.features.auth.data.remote.dto.RegisterRequest
import com.mobileshop.features.auth.domain.use_case.RegisterUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

// Estado para la UI
data class RegisterState(
    val isLoading: Boolean = false
)

sealed class RegisterEvent {
    data class Success(val message: String) : RegisterEvent()
    data class Error(val message: String) : RegisterEvent()
}

@HiltViewModel
class RegisterViewModel @Inject constructor(
    private val registerUseCase: RegisterUseCase
) : ViewModel() {

    private val _state = MutableStateFlow(RegisterState())
    val registerState = _state.asStateFlow()

    private val _eventFlow = MutableSharedFlow<RegisterEvent>()
    val eventFlow = _eventFlow.asSharedFlow()

    fun onRegisterClicked(email: String, pass: String) {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = true) }
            val request = RegisterRequest(email = email, password = pass, role = "admin")

            registerUseCase(request)
                .onSuccess {
                    _eventFlow.emit(RegisterEvent.Success("¡Administrador registrado!"))
                }
                .onFailure {
                    _eventFlow.emit(RegisterEvent.Error(it.message ?: "Error desconocido"))
                }
            _state.update { it.copy(isLoading = false) }
        }
    }
}
===== ./app/src/main/java/com/mobileshop/features/products/data/local/ProductDao.kt =====
package com.mobileshop.features.products.data.local

import androidx.room.*
import kotlinx.coroutines.flow.Flow

@Dao
interface ProductDao {

    // --- Operaciones de Lectura ---
    @Query("SELECT * FROM products WHERE pendingDeletion = 0 ORDER BY name ASC")
    fun getAllProducts(): Flow<List<ProductEntity>>

    @Query("SELECT * FROM products WHERE serverId = :serverId")
    suspend fun getProductByServerId(serverId: String): ProductEntity?

    // --- Operaciones de Sincronización ---
    @Query("SELECT * FROM products WHERE isSynced = 0")
    suspend fun getUnsyncedProducts(): List<ProductEntity>

    @Query("SELECT * FROM products WHERE pendingDeletion = 1")
    suspend fun getProductsPendingDeletion(): List<ProductEntity>

    // --- Operaciones de Escritura ---
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertAll(products: List<ProductEntity>)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(product: ProductEntity): Long

    @Query("UPDATE products SET pendingDeletion = 1, isSynced = 0 WHERE serverId = :serverId")
    suspend fun markForDeletion(serverId: String)

    @Query("DELETE FROM products WHERE localId IN (:ids)")
    suspend fun deleteByLocalIds(ids: List<Int>)
}
===== ./app/src/main/java/com/mobileshop/features/products/data/local/ProductEntity.kt =====
package com.mobileshop.features.products.data.local

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "products") // Cambiamos el nombre a algo más general
data class ProductEntity(
    @PrimaryKey(autoGenerate = true)
    val localId: Int = 0,
    val serverId: String?, // El ID que viene del servidor (_id). Es nullable para productos nuevos creados offline.
    var name: String,
    var description: String,
    var price: Double,
    var stock: Int,
    var imagePath: String?, // Ruta local o URL remota
    var isSynced: Boolean = true, // 'false' si es nuevo o modificado y no se ha enviado
    var pendingDeletion: Boolean = false // 'true' si debe ser eliminado en la próxima sincronización
)
===== ./app/src/main/java/com/mobileshop/features/products/data/mapper/ProductMapper.kt =====
package com.mobileshop.features.products.data.mapper

import com.mobileshop.core.data.remote.dto.ProductDto
import com.mobileshop.features.products.domain.model.Product

fun ProductDto.toProduct(): Product {
    return Product(
        id = this.id,
        name = this.nombre,
        description = this.descripcion,
        price = this.precio,
        stock = this.stock,
        imageUrl = this.imagenUrl
    )
}
===== ./app/src/main/java/com/mobileshop/features/products/data/remote/dto/CreateProductRequest.kt =====
package com.mobileshop.features.products.data.remote.dto

// Este DTO se usa para enviar un nuevo producto al servidor
data class CreateProductRequest(
    val nombre: String,
    val descripcion: String,
    val precio: Double,
    val stock: Int
)
===== ./app/src/main/java/com/mobileshop/features/products/data/repository/ProductRepositoryImpl.kt =====
package com.mobileshop.features.products.data.repository

import android.content.Context
import android.net.Uri
import com.mobileshop.core.common.ConnectivityObserver
import com.mobileshop.core.data.remote.ApiService
import com.mobileshop.features.products.data.local.ProductDao
import com.mobileshop.features.products.data.local.ProductEntity
import com.mobileshop.features.products.domain.model.Product
import com.mobileshop.features.products.domain.repository.ProductRepository
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.MultipartBody
import okhttp3.RequestBody.Companion.toRequestBody
import java.io.File
import javax.inject.Inject

class ProductRepositoryImpl @Inject constructor(
    private val apiService: ApiService,
    private val productDao: ProductDao,
    private val connectivityObserver: ConnectivityObserver,
    @ApplicationContext private val context: Context
) : ProductRepository {

    // --- LECTURA: LA FUENTE DE VERDAD ES SIEMPRE ROOM ---
    override fun getProducts(): Flow<Result<List<Product>>> {
        return productDao.getAllProducts().map { entities ->
            Result.success(entities.map { it.toProduct() })
        }
    }

    override suspend fun getProductById(id: String): Result<Product> {
        return try {
            val entity = productDao.getProductByServerId(id)
            if (entity != null) {
                Result.success(entity.toProduct())
            } else {
                Result.failure(Exception("Producto no encontrado localmente"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    // --- ESCRITURA: LÓGICA OFFLINE-FIRST ---
    override suspend fun createProduct(name: String, description: String, price: Double, stock: Int, imageUri: Uri?): Result<Unit> {
        return try {
            val imagePath = imageUri?.let { saveImageLocally(it) }
            val newProduct = ProductEntity(
                serverId = null, // Aún no tiene ID del servidor
                name = name,
                description = description,
                price = price,
                stock = stock,
                imagePath = imagePath,
                isSynced = false, // Marcado como pendiente de sincronización
                pendingDeletion = false
            )
            productDao.upsert(newProduct)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    override suspend fun updateProduct(id: String, name: String, description: String, price: Double, stock: Int, imageUri: Uri?): Result<Unit> {
        return try {
            val productToUpdate = productDao.getProductByServerId(id)
                ?: return Result.failure(Exception("Producto no encontrado para actualizar"))

            val imagePath = imageUri?.let { saveImageLocally(it) }

            productToUpdate.apply {
                this.name = name
                this.description = description
                this.price = price
                this.stock = stock
                if (imagePath != null) this.imagePath = imagePath
                this.isSynced = false // Marcado como pendiente de sincronización
            }
            productDao.upsert(productToUpdate)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    override suspend fun deleteProduct(id: String): Result<Unit> {
        return try {
            productDao.markForDeletion(id)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    // --- SINCRONIZACIÓN ---
    override suspend fun syncWithRemote() {
        if (connectivityObserver.observe().first() != ConnectivityObserver.Status.Available) {
            return // No hay conexión, no hacemos nada
        }

        try {
            // 1. Enviar cambios locales al servidor (nuevos, modificados, eliminados)
            syncLocalDeletions()
            syncLocalUpserts()

            // 2. Traer la lista actualizada del servidor
            val remoteProducts = apiService.getProducts().data.products
            val productEntities = remoteProducts.map { dto ->
                ProductEntity(
                    serverId = dto.id,
                    name = dto.nombre,
                    description = dto.descripcion,
                    price = dto.precio,
                    stock = dto.stock,
                    imagePath = dto.imagenUrl,
                    isSynced = true,
                    pendingDeletion = false
                )
            }
            productDao.upsertAll(productEntities)

        } catch (e: Exception) {
            // Manejar errores de sincronización (e.g., log, mostrar notificación)
            println("Error de sincronización: ${e.message}")
        }
    }

    // ... (dentro de la clase ProductRepositoryImpl)

    // ... (dentro de la clase ProductRepositoryImpl)

    private suspend fun syncLocalUpserts() {
        // Obtenemos solo los productos que han sido modificados o son nuevos
        val unsyncedProducts = productDao.getUnsyncedProducts().filter { !it.pendingDeletion }
        if (unsyncedProducts.isEmpty()) return

        unsyncedProducts.forEach { localProduct ->
            try {
                // Preparamos los datos comunes como RequestBody
                val nombreBody = localProduct.name.toRequestBody("text/plain".toMediaTypeOrNull())
                val descripcionBody = localProduct.description.toRequestBody("text/plain".toMediaTypeOrNull())
                val precioBody = localProduct.price.toString().toRequestBody("text/plain".toMediaTypeOrNull())
                val stockBody = localProduct.stock.toString().toRequestBody("text/plain".toMediaTypeOrNull())

                // Preparamos la imagen (si existe) como MultipartBody.Part
                val imagePart: MultipartBody.Part? = localProduct.imagePath?.let { path ->
                    val file = File(path)
                    if (file.exists()) {
                        val requestFile = file.readBytes().toRequestBody("image/jpeg".toMediaTypeOrNull())
                        MultipartBody.Part.createFormData("imagen", file.name, requestFile)
                    } else {
                        null
                    }
                }

                // Decidimos si es una ACTUALIZACIÓN (PUT) o una CREACIÓN (POST)
                if (localProduct.serverId != null) {
                    // --- CORRECCIÓN AQUÍ: Pasamos TODOS los parámetros ---
                    apiService.updateProduct(
                        id = localProduct.serverId!!,
                        nombre = nombreBody,
                        descripcion = descripcionBody,
                        precio = precioBody,
                        stock = stockBody,
                        imagen = imagePart
                    )
                } else {
                    // --- CORRECCIÓN AQUÍ: Pasamos TODOS los parámetros ---
                    apiService.createProduct(
                        nombre = nombreBody,
                        descripcion = descripcionBody,
                        precio = precioBody,
                        stock = stockBody,
                        imagen = imagePart
                    )
                }
                // Si la sincronización individual es exitosa, podrías marcar este producto como sincronizado.
                // Sin embargo, es más robusto esperar a la descarga completa para asegurar la consistencia.
            } catch (e: Exception) {
                println("Fallo al sincronizar producto localId ${localProduct.localId}: ${e.message}")
            }
        }
    }

    private suspend fun syncLocalDeletions() {
        val productsToDelete = productDao.getProductsPendingDeletion()
        if (productsToDelete.isNotEmpty()) {
            productsToDelete.forEach { product ->
                try {
                    product.serverId?.let { apiService.deleteProduct(it) }
                } catch (e: Exception) {
                    println("Fallo al eliminar producto ${product.serverId} en el servidor: ${e.message}")
                }
            }
            productDao.deleteByLocalIds(productsToDelete.map { it.localId })
        }
    }

    // --- MÉTODOS DE AYUDA ---
    private fun ProductEntity.toProduct(): Product {
        return Product(
            id = this.serverId ?: "local_${this.localId}",
            name = this.name,
            description = this.description,
            price = this.price,
            stock = this.stock,
            imageUrl = this.imagePath
        )
    }

    private fun saveImageLocally(uri: Uri): String {
        // ... (tu implementación actual es correcta)
        val inputStream = context.contentResolver.openInputStream(uri)
        val file = File(context.filesDir, "product_${System.currentTimeMillis()}.jpg")
        inputStream?.use { input ->
            file.outputStream().use { output ->
                input.copyTo(output)
            }
        }
        return file.absolutePath
    }
}
===== ./app/src/main/java/com/mobileshop/features/products/domain/model/Product.kt =====
package com.mobileshop.features.products.domain.model

data class Product(
    val id: String,
    val name: String,
    val description: String,
    val price: Double,
    val stock: Int,
    val imageUrl: String?
)
===== ./app/src/main/java/com/mobileshop/features/products/domain/repository/ProductRepository.kt =====
package com.mobileshop.features.products.domain.repository

import com.mobileshop.features.products.domain.model.Product
import android.net.Uri
import kotlinx.coroutines.flow.Flow

interface ProductRepository {
    // CAMBIO: Ahora devuelve un Flow para que la UI se actualice automáticamente
    fun getProducts(): Flow<Result<List<Product>>>

    suspend fun getProductById(id: String): Result<Product>
    suspend fun createProduct(name: String, description: String, price: Double, stock: Int, imageUri: Uri?): Result<Unit>
    suspend fun updateProduct(id: String, name: String, description: String, price: Double, stock: Int, imageUri: Uri?): Result<Unit>
    suspend fun deleteProduct(id: String): Result<Unit>

    // NUEVO: Método para iniciar la sincronización
    suspend fun syncWithRemote()
}
===== ./app/src/main/java/com/mobileshop/features/products/domain/use_case/CreateProductUseCase.kt =====
package com.mobileshop.features.products.domain.use_case

import com.mobileshop.features.products.domain.repository.ProductRepository
import javax.inject.Inject
import android.net.Uri

class CreateProductUseCase @Inject constructor(
    private val repository: ProductRepository
) {
    suspend operator fun invoke(name: String, description: String, price: Double, stock: Int, imageUri: Uri?) =
        repository.createProduct(name, description, price, stock, imageUri)
}
===== ./app/src/main/java/com/mobileshop/features/products/domain/use_case/DeleteProductUseCase.kt =====
package com.mobileshop.features.products.domain.use_case

import com.mobileshop.features.products.domain.repository.ProductRepository
import javax.inject.Inject

class DeleteProductUseCase @Inject constructor(private val repository: ProductRepository) {
    suspend operator fun invoke(id: String) = repository.deleteProduct(id)
}
===== ./app/src/main/java/com/mobileshop/features/products/domain/use_case/GetProductByIdUseCase.kt =====
package com.mobileshop.features.products.domain.use_case

import com.mobileshop.features.products.domain.repository.ProductRepository
import javax.inject.Inject

class GetProductByIdUseCase @Inject constructor(private val repository: ProductRepository) {
    suspend operator fun invoke(id: String) = repository.getProductById(id)
}

===== ./app/src/main/java/com/mobileshop/features/products/domain/use_case/GetProductsUseCase.kt =====
package com.mobileshop.features.products.domain.use_case

import com.mobileshop.features.products.domain.repository.ProductRepository
import javax.inject.Inject

class GetProductsUseCase @Inject constructor(
    private val repository: ProductRepository
) {
    suspend operator fun invoke() = repository.getProducts()
}
===== ./app/src/main/java/com/mobileshop/features/products/domain/use_case/UpdateProductUseCase.kt =====
package com.mobileshop.features.products.domain.use_case

import android.net.Uri
import com.mobileshop.features.products.domain.repository.ProductRepository
import javax.inject.Inject

class UpdateProductUseCase @Inject constructor(private val repository: ProductRepository) {
    suspend operator fun invoke(id: String, name: String, description: String, price: Double, stock: Int, imageUri: Uri?) =
        repository.updateProduct(id, name, description, price, stock, imageUri)
}
===== ./app/src/main/java/com/mobileshop/features/products/presentation/AddProductScreen.kt =====
package com.mobileshop.features.products.presentation

import android.Manifest
import android.net.Uri
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.rememberAsyncImagePainter

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddProductScreen(
    viewModel: ProductsViewModel = hiltViewModel(),
    onProductCreated: () -> Unit
) {
    var name by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }
    var price by remember { mutableStateOf("") }
    var stock by remember { mutableStateOf("") }

    // Este es el estado que la UI observará para mostrar la imagen.
    var imageUri by remember { mutableStateOf<Uri?>(null) }

    // <-- CAMBIO 1: Usaremos una variable temporal para pasar la URI a la cámara.
    // No es un 'remember' porque no necesita sobrevivir recomposiciones.
    var tempCameraUri: Uri? = null

    val context = LocalContext.current
    val state by viewModel.state.collectAsState()

    // <-- CAMBIO 2: Modificamos el callback del launcher de la cámara.
    val cameraLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.TakePicture(),
        onResult = { success ->
            if (success) {
                // Si la foto se tomó correctamente, AHORA actualizamos el estado de la UI.
                imageUri = tempCameraUri
            } else {
                Toast.makeText(context, "Captura cancelada", Toast.LENGTH_SHORT).show()
            }
        }
    )

    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission(),
        onResult = { isGranted ->
            if (isGranted) {
                // Si se concede el permiso, creamos la URI y lanzamos la cámara.
                tempCameraUri = viewModel.createImageUri(context)
                cameraLauncher.launch(tempCameraUri!!)
            } else {
                Toast.makeText(context, "Permiso de cámara denegado", Toast.LENGTH_SHORT).show()
            }
        }
    )

    LaunchedEffect(state.isProductCreated) {
        if (state.isProductCreated) {
            Toast.makeText(context, "Producto creado exitosamente", Toast.LENGTH_SHORT).show()
            viewModel.resetProductCreationStatus()
            onProductCreated()
        }
    }

    Scaffold(
        topBar = { TopAppBar(title = { Text("Añadir Producto") }) }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp)
                .verticalScroll(rememberScrollState()), // Añadimos scroll por si el teclado ocupa mucho espacio
            verticalArrangement = Arrangement.spacedBy(12.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .background(MaterialTheme.colorScheme.surfaceVariant), // Usamos un color del tema
                contentAlignment = Alignment.Center
            ) {
                if (imageUri != null) {
                    Image(
                        painter = rememberAsyncImagePainter(model = imageUri),
                        contentDescription = "Imagen del producto",
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Crop
                    )
                } else {
                    Text("Toma una foto para el producto")
                }
            }

            OutlinedTextField(value = name, onValueChange = { name = it }, label = { Text("Nombre") }, modifier = Modifier.fillMaxWidth())
            OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text("Descripción") }, modifier = Modifier.fillMaxWidth(), minLines = 3)
            OutlinedTextField(value = price, onValueChange = { price = it }, label = { Text("Precio") }, keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal), modifier = Modifier.fillMaxWidth())
            OutlinedTextField(value = stock, onValueChange = { stock = it }, label = { Text("Stock") }, keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number), modifier = Modifier.fillMaxWidth())

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                Button(
                    onClick = {
                        // <-- CAMBIO 3: La lógica del botón ahora usa la variable temporal.
                        if (viewModel.hasCameraPermission(context)) {
                            tempCameraUri = viewModel.createImageUri(context)
                            cameraLauncher.launch(tempCameraUri)
                        } else {
                            permissionLauncher.launch(Manifest.permission.CAMERA)
                        }
                    },
                    modifier = Modifier.weight(1f)
                ) {
                    Text("Tomar Foto")
                }

                Button(
                    onClick = {
                        viewModel.createProduct(
                            name = name,
                            description = description,
                            price = price.toDoubleOrNull() ?: 0.0,
                            stock = stock.toIntOrNull() ?: 0,
                            imageUri = imageUri
                        )
                    },
                    enabled = !state.isLoading,
                    modifier = Modifier.weight(1f)
                ) {
                    if (state.isLoading) {
                        CircularProgressIndicator(modifier = Modifier.size(24.dp), color = MaterialTheme.colorScheme.onPrimary)
                    } else {
                        Text("Guardar")
                    }
                }
            }
            state.error?.let {
                Text(text = it, color = MaterialTheme.colorScheme.error, modifier = Modifier.padding(top = 8.dp))
            }
        }
    }
}
===== ./app/src/main/java/com/mobileshop/features/products/presentation/ProductDetailScreen.kt =====
package com.mobileshop.features.products.presentation

import android.widget.Toast
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProductDetailScreen(
    viewModel: ProductDetailViewModel = hiltViewModel(),
    onNavigateBack: () -> Unit
) {
    val state by viewModel.state.collectAsState()
    val context = LocalContext.current

    // Estados para los campos de texto
    var name by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }
    var price by remember { mutableStateOf("") }
    var stock by remember { mutableStateOf("") }

    // Rellenar los campos cuando el producto se cargue
    LaunchedEffect(state.product) {
        state.product?.let {
            name = it.name
            description = it.description
            price = it.price.toString()
            stock = it.stock.toString()
        }
    }

    // Efectos para mostrar Toasts y navegar hacia atrás
    LaunchedEffect(state.isUpdated, state.isDeleted) {
        if (state.isUpdated) {
            Toast.makeText(context, "Producto actualizado", Toast.LENGTH_SHORT).show()
            onNavigateBack()
        }
        if (state.isDeleted) {
            Toast.makeText(context, "Producto eliminado", Toast.LENGTH_SHORT).show()
            onNavigateBack()
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Editar Producto") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        // ✅ CORRECCIÓN: Usamos el icono AutoMirrored
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Volver")
                    }
                },
                actions = {
                    IconButton(onClick = { viewModel.deleteProduct() }) {
                        Icon(Icons.Default.Delete, contentDescription = "Eliminar")
                    }
                }
            )
        }
    ) { padding ->
        if (state.isLoading && state.product == null) {
            Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        } else if (state.product != null) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                OutlinedTextField(value = name, onValueChange = { name = it }, label = { Text("Nombre") }, modifier = Modifier.fillMaxWidth())
                OutlinedTextField(value = description, onValueChange = { description = it }, label = { Text("Descripción") }, modifier = Modifier.fillMaxWidth())
                OutlinedTextField(value = price, onValueChange = { price = it }, label = { Text("Precio") }, modifier = Modifier.fillMaxWidth())
                OutlinedTextField(value = stock, onValueChange = { stock = it }, label = { Text("Stock") }, modifier = Modifier.fillMaxWidth())

                Button(
                    onClick = {
                        viewModel.updateProduct(
                            name = name,
                            description = description,
                            price = price.toDoubleOrNull() ?: 0.0,
                            stock = stock.toIntOrNull() ?: 0
                        )
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = !state.isLoading
                ) {
                    if (state.isLoading) {
                        CircularProgressIndicator(modifier = Modifier.size(24.dp))
                    } else {
                        Text("Actualizar Producto")
                    }
                }
            }
        }
    }
}
===== ./app/src/main/java/com/mobileshop/features/products/presentation/ProductDetailState.kt =====
package com.mobileshop.features.products.presentation

import com.mobileshop.features.products.domain.model.Product

data class ProductDetailState(
    val isLoading: Boolean = false,
    val product: Product? = null,
    val error: String? = null,
    val isUpdated: Boolean = false,
    val isDeleted: Boolean = false
)
===== ./app/src/main/java/com/mobileshop/features/products/presentation/ProductDetailViewModel.kt =====
package com.mobileshop.features.products.presentation

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.mobileshop.features.products.domain.use_case.*
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class ProductDetailViewModel @Inject constructor(
    private val getProductByIdUseCase: GetProductByIdUseCase,
    private val updateProductUseCase: UpdateProductUseCase,
    private val deleteProductUseCase: DeleteProductUseCase,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val productId: String = savedStateHandle.get<String>("productId")!!

    private val _state = MutableStateFlow(ProductDetailState())
    val state = _state.asStateFlow()

    init {
        loadProduct()
    }

    fun loadProduct() {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = true) }
            getProductByIdUseCase(productId)
                .onSuccess { product ->
                    _state.update { it.copy(isLoading = false, product = product) }
                }
                .onFailure { error ->
                    _state.update { it.copy(isLoading = false, error = error.message) }
                }
        }
    }

    fun updateProduct(name: String, description: String, price: Double, stock: Int) {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = true) }
            updateProductUseCase(productId, name, description, price, stock, null) // Sin imagen por ahora
                .onSuccess { _state.update { it.copy(isLoading = false, isUpdated = true) } }
                .onFailure { e -> _state.update { it.copy(isLoading = false, error = e.message) } }
        }
    }

    fun deleteProduct() {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = true) }
            deleteProductUseCase(productId)
                .onSuccess { _state.update { it.copy(isLoading = false, isDeleted = true) } }
                .onFailure { e -> _state.update { it.copy(isLoading = false, error = e.message) } }
        }
    }
}
===== ./app/src/main/java/com/mobileshop/features/products/presentation/ProductsScreen.kt =====
package com.mobileshop.features.products.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.automirrored.filled.ExitToApp
import androidx.compose.material.icons.filled.ImageNotSupported
import androidx.compose.material.icons.filled.PersonAdd
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import coil.compose.AsyncImagePainter
import coil.compose.rememberAsyncImagePainter
import com.mobileshop.R
import com.mobileshop.navigation.Routes

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProductsScreen(
    viewModel: ProductsViewModel = hiltViewModel(),
    onAddProductClick: () -> Unit,
    onProductClick: (String) -> Unit,
    onRegisterClick: () -> Unit,
    navController: NavController
) {
    val state by viewModel.state.collectAsState()

    // Escucha eventos del ViewModel para navegar al login tras logout
    LaunchedEffect(key1 = true) {
        viewModel.uiEvent.collect { event ->
            when (event) {
                is ProductsViewModel.UIEvent.NavigateToLogin -> {
                    navController.navigate(Routes.LOGIN) {
                        popUpTo(navController.graph.id) { inclusive = true }
                    }
                }
            }
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("MobileShop") },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary
                ),
                actions = {
                    IconButton(onClick = onRegisterClick) {
                        Icon(
                            imageVector = Icons.Default.PersonAdd,
                            contentDescription = "Registrar Administrador",
                            tint = MaterialTheme.colorScheme.onPrimary
                        )
                    }
                    IconButton(onClick = { viewModel.onLogout() }) {
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ExitToApp,
                            contentDescription = "Cerrar sesión",
                            tint = MaterialTheme.colorScheme.onPrimary
                        )
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(onClick = onAddProductClick) {
                Icon(
                    imageVector = Icons.Default.Add,
                    contentDescription = "Añadir Producto"
                )
            }
        }
    ) { padding ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
        ) {
            if (state.isLoading) {
                CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
            }

            state.error?.let { error ->
                Text(
                    text = "Error: $error",
                    color = MaterialTheme.colorScheme.error,
                    modifier = Modifier
                        .align(Alignment.Center)
                        .padding(16.dp)
                )
            }

            LazyVerticalGrid(
                columns = GridCells.Fixed(2),
                modifier = Modifier.fillMaxSize(),
                contentPadding = PaddingValues(8.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(state.products) { product ->
                    ProductCard(
                        product = product,
                        onClick = { onProductClick(product.id) } // <-- Llamar a la lambda
                    )
                }
            }
        }
    }
}

@Composable
fun ProductCard(product: com.mobileshop.features.products.domain.model.Product, onClick: () -> Unit) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        shape = MaterialTheme.shapes.medium
    ) {
        Column {
            val painter = rememberAsyncImagePainter(
                model = product.imageUrl,
                error = rememberAsyncImagePainter(model = R.drawable.ic_placeholder_error),
                placeholder = rememberAsyncImagePainter(model = R.drawable.ic_placeholder_loading)
            )

            Box(
                modifier = Modifier
                    .height(180.dp)
                    .fillMaxWidth(),
                contentAlignment = Alignment.Center
            ) {
                when (painter.state) {
                    is AsyncImagePainter.State.Loading -> {
                        CircularProgressIndicator(modifier = Modifier.size(32.dp))
                    }
                    is AsyncImagePainter.State.Error -> {
                        Icon(
                            imageVector = Icons.Default.ImageNotSupported,
                            contentDescription = "Error de imagen",
                            modifier = Modifier.size(48.dp),
                            tint = Color.Gray
                        )
                    }
                    else -> Unit
                }
                Image(
                    painter = painter,
                    contentDescription = product.name,
                    contentScale = ContentScale.Crop,
                    modifier = Modifier.fillMaxSize()
                )
            }

            Column(
                modifier = Modifier.padding(12.dp)
            ) {
                Text(
                    text = product.name,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis,
                    minLines = 2
                )

                Spacer(modifier = Modifier.height(4.dp))

                Text(
                    text = "$${"%.2f".format(product.price)}",
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.SemiBold,
                    color = MaterialTheme.colorScheme.primary
                )

                Spacer(modifier = Modifier.height(8.dp))

                Text(
                    text = "Disponibles: ${product.stock}",
                    style = MaterialTheme.typography.bodySmall,
                    color = Color.Gray,
                    fontSize = 12.sp
                )
            }
        }
    }
}

===== ./app/src/main/java/com/mobileshop/features/products/presentation/ProductsState.kt =====
package com.mobileshop.features.products.presentation

import com.mobileshop.features.products.domain.model.Product

data class ProductsState(
    val isLoading: Boolean = false,
    val isSyncing: Boolean = false, // Para mostrar un indicador de sincronización
    val products: List<Product> = emptyList(),
    val error: String? = null,
    val isProductCreated: Boolean = false
)
===== ./app/src/main/java/com/mobileshop/features/products/presentation/ProductsViewModel.kt =====
package com.mobileshop.features.products.presentation

import android.content.Context
import android.net.Uri
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.mobileshop.core.domain.camera.CameraManager
import com.mobileshop.features.auth.domain.use_case.LogoutUseCase
import com.mobileshop.features.products.domain.repository.ProductRepository // Importa la interfaz
import com.mobileshop.features.products.domain.use_case.* // Importa todos los casos de uso
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class ProductsViewModel @Inject constructor(
    private val productRepository: ProductRepository, // Inyectamos el Repositorio
    private val createProductUseCase: CreateProductUseCase, // Lo mantenemos para crear
    private val logoutUseCase: LogoutUseCase,
    private val cameraManager: CameraManager
) : ViewModel() {

    private val _state = MutableStateFlow(ProductsState())
    val state = _state.asStateFlow()

    private val _uiEvent = Channel<UIEvent>(Channel.BUFFERED)
    val uiEvent = _uiEvent.receiveAsFlow()

    init {
        observeProducts()
        syncData()
    }

    private fun observeProducts() {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = true) }
            productRepository.getProducts().collect { result ->
                result.onSuccess { products ->
                    _state.update { it.copy(isLoading = false, products = products, error = null) }
                }.onFailure { error ->
                    _state.update { it.copy(isLoading = false, error = error.message) }
                }
            }
        }
    }

    fun syncData() {
        viewModelScope.launch {
            _state.update { it.copy(isSyncing = true) } // Opcional: mostrar un indicador de sync
            productRepository.syncWithRemote()
            _state.update { it.copy(isSyncing = false) }
        }
    }

    fun createProduct(name: String, description: String, price: Double, stock: Int, imageUri: Uri?) {
        viewModelScope.launch {
            createProductUseCase(name, description, price, stock, imageUri)
                .onFailure { error ->
                    _state.update { it.copy(error = error.message) }
                }
                .onSuccess {
                    _state.update { it.copy(isProductCreated = true) } // Para la navegación
                    syncData() // Intentamos sincronizar inmediatamente después de crear
                }
        }
    }

    // ... el resto de tus funciones (hasCameraPermission, onLogout, etc.) se mantienen igual
    fun hasCameraPermission(context: Context): Boolean = cameraManager.hasCameraPermission(context)
    fun createImageUri(context: Context): Uri = cameraManager.createImageUri(context)
    fun resetProductCreationStatus() = _state.update { it.copy(isProductCreated = false) }

    fun onLogout() {
        viewModelScope.launch {
            logoutUseCase()
            _uiEvent.send(UIEvent.NavigateToLogin)
        }
    }

    sealed class UIEvent {
        object NavigateToLogin : UIEvent()
    }
}
===== ./app/src/main/java/com/mobileshop/features/sync/data/repository/SyncRepositoryImpl.kt =====
package com.mobileshop.features.sync.data.repository

import com.mobileshop.core.data.local.TokenManager
import com.mobileshop.core.data.remote.ApiService
import com.mobileshop.core.data.remote.dto.ProductSyncDto
import com.mobileshop.core.data.remote.dto.SyncRequest
import com.mobileshop.features.products.data.local.ProductDao
import com.mobileshop.features.products.data.local.ProductEntity
import com.mobileshop.features.sync.domain.repository.SyncRepository
import javax.inject.Inject

class SyncRepositoryImpl @Inject constructor(
    private val apiService: ApiService,
    private val productDao: ProductDao,
    private val tokenManager: TokenManager
) : SyncRepository {

    override suspend fun performSync(): Result<Unit> {
        return try {
            // 1. Subir cambios locales (sin cambios aquí)
            uploadDeletions()
            uploadUpserts()

            // 2. Bajar cambios del servidor (lógica corregida)
            downloadAllProducts()

            tokenManager.saveLastSyncTimestamp(System.currentTimeMillis()) // Guardamos la fecha actual
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    // ... uploadDeletions y uploadUpserts se mantienen igual ...
    private suspend fun uploadDeletions() {
        val pendingDeletions = productDao.getProductsPendingDeletion()
        pendingDeletions.forEach { entity ->
            entity.serverId?.let { serverId ->
                apiService.deleteProduct(serverId)
                productDao.deleteByLocalIds(listOf(entity.localId))
            }
        }
    }

    private suspend fun uploadUpserts() {
        val unsynced = productDao.getUnsyncedProducts().filter { !it.pendingDeletion }
        if (unsynced.isEmpty()) return

        val syncDtos = unsynced.map {
            ProductSyncDto(
                tempId = "local_${it.localId}",
                nombre = it.name,
                descripcion = it.description,
                precio = it.price,
                stock = it.stock
            )
        }
        apiService.syncProducts(SyncRequest(products = syncDtos))
    }

    // ✅ CORRECCIÓN COMPLETA DE ESTA FUNCIÓN
    private suspend fun downloadAllProducts() {
        // Llamamos al endpoint que sí existe para obtener la lista completa.
        val remoteProductsResponse = apiService.getAllProductsForSync()

        // Mapeamos los DTOs remotos a Entidades de Room.
        val entities = remoteProductsResponse.data.map { dto ->
            ProductEntity(
                // Buscamos si ya existe localmente para no perder el localId
                localId = productDao.getProductByServerId(dto.id)?.localId ?: 0,
                serverId = dto.id,
                name = dto.nombre,
                description = dto.descripcion,
                price = dto.precio,
                stock = dto.stock,
                imagePath = dto.imagenUrl,
                isSynced = true, // Todos los datos que vienen del server están sincronizados
                pendingDeletion = false // Los productos activos no están pendientes de borrado
            )
        }
        // Usamos upsertAll para insertar los nuevos y actualizar los existentes en una sola operación.
        productDao.upsertAll(entities)
    }
}
===== ./app/src/main/java/com/mobileshop/features/sync/domain/repository/SyncRepository.kt =====
package com.mobileshop.features.sync.domain.repository

interface SyncRepository {
    suspend fun performSync(): Result<Unit>
}
===== ./app/src/main/java/com/mobileshop/features/sync/domain/use_case/SyncDataUseCase.kt =====
package com.mobileshop.features.sync.domain.use_case

import com.mobileshop.features.sync.domain.repository.SyncRepository
import javax.inject.Inject

class SyncDataUseCase @Inject constructor(
    private val syncRepository: SyncRepository
) {
    suspend operator fun invoke() = syncRepository.performSync()
}
===== ./app/src/main/java/com/mobileshop/features/sync/presentation/service/SyncService.kt =====
package com.mobileshop.features.sync.presentation.service

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.Service
import android.content.Intent
import android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC // <-- ✅ 1. IMPORTA EL TIPO
import android.os.Build
import android.os.IBinder
import androidx.core.app.NotificationCompat
import com.mobileshop.R
import com.mobileshop.features.sync.domain.use_case.SyncDataUseCase
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.*
import javax.inject.Inject

@AndroidEntryPoint
class SyncService : Service() {

    @Inject
    lateinit var syncDataUseCase: SyncDataUseCase

    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        createNotificationChannel()
        val notification = buildNotification("Sincronizando datos...")

        // ✅ 2. ESPECIFICA EL TIPO DE SERVICIO AL INICIAR
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            startForeground(NOTIFICATION_ID, notification, FOREGROUND_SERVICE_TYPE_DATA_SYNC)
        } else {
            // Para versiones antiguas que no requieren el tipo
            startForeground(NOTIFICATION_ID, notification)
        }

        serviceScope.launch {
            syncDataUseCase().onSuccess {
                updateNotification("Sincronización completada.")
            }.onFailure {
                updateNotification("Error de sincronización.")
            }
            delay(3000)
            stopSelf()
        }

        return START_NOT_STICKY
    }

    // ... el resto del archivo se mantiene igual ...
    override fun onDestroy() {
        super.onDestroy()
        serviceScope.cancel()
    }

    override fun onBind(intent: Intent?): IBinder? = null

    private fun buildNotification(contentText: String): Notification {
        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("MobileShop Sync")
            .setContentText(contentText)
            .setSmallIcon(R.drawable.ic_placeholder_loading)
            .setOngoing(true)
            .build()
    }

    private fun updateNotification(contentText: String) {
        val notification = buildNotification(contentText).apply {
            flags = flags and Notification.FLAG_ONGOING_EVENT.inv()
        }
        val manager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager
        manager.notify(NOTIFICATION_ID, notification)
    }

    private fun createNotificationChannel() {
        val channel = NotificationChannel(
            CHANNEL_ID,
            "Sincronización de Datos",
            NotificationManager.IMPORTANCE_LOW
        )
        val manager = getSystemService(NotificationManager::class.java)
        manager.createNotificationChannel(channel)
    }

    companion object {
        const val CHANNEL_ID = "sync_channel"
        const val NOTIFICATION_ID = 101
    }
}
===== ./app/src/main/java/com/mobileshop/MainActivity.kt =====
package com.mobileshop

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import com.mobileshop.core.common.ConnectivityObserver
import com.mobileshop.features.sync.presentation.service.SyncService
import com.mobileshop.navigation.AppNavigation
import com.mobileshop.ui.theme.MobileShopTheme
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import javax.inject.Inject

@AndroidEntryPoint
class MainActivity : ComponentActivity() {

    @Inject
    lateinit var connectivityObserver: ConnectivityObserver

    // Launcher para pedir permiso de notificaciones en Android 13+
    private val requestPermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
            if (isGranted) {
                startSyncService()
            }
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        observeNetwork()

        setContent {
            MobileShopTheme {
                AppNavigation()
            }
        }
    }

    private fun observeNetwork() {
        connectivityObserver.observe()
            .onEach { status ->
                // Cuando la red esté disponible, intenta sincronizar.
                if (status == ConnectivityObserver.Status.Available) {
                    checkPermissionsAndSync()
                }
            }
            .launchIn(lifecycleScope)
    }

    private fun checkPermissionsAndSync() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
        } else {
            startSyncService()
        }
    }

    private fun startSyncService() {
        val intent = Intent(this, SyncService::class.java)
        startService(intent)
    }
}
===== ./app/src/main/java/com/mobileshop/MyApplication.kt =====
package com.mobileshop

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class MyApplication : Application() {}
===== ./app/src/main/java/com/mobileshop/navigation/Navigation.kt =====
// AppNavigation.kt
package com.mobileshop.navigation

import androidx.compose.runtime.Composable
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.mobileshop.features.auth.presentation.login.LoginScreen
import com.mobileshop.features.auth.presentation.register.RegisterScreen
import com.mobileshop.features.products.presentation.AddProductScreen
import com.mobileshop.features.products.presentation.ProductsScreen
import com.mobileshop.features.products.presentation.ProductDetailScreen

object Routes {
    const val SPLASH = "splash"
    const val LOGIN = "login"
    const val REGISTER = "register"
    const val PRODUCT_LIST = "product_list"
    const val ADD_PRODUCT = "add_product"
    const val PRODUCT_DETAIL = "product_detail"
}

@Composable
fun AppNavigation() {
    val navController = rememberNavController()

    NavHost(navController, startDestination = Routes.SPLASH) {
        composable(Routes.SPLASH) { SplashScreen(navController) }
        composable(Routes.LOGIN) {
            LoginScreen(onLoginSuccess = {
                navController.navigate(Routes.PRODUCT_LIST) {
                    popUpTo(navController.graph.startDestinationId) { inclusive = true }
                }
            },
                onNavigateToRegister = { navController.navigate(Routes.REGISTER) })
        }
        composable(Routes.PRODUCT_LIST) {
            ProductsScreen(
                navController = navController,
                onAddProductClick = { navController.navigate(Routes.ADD_PRODUCT) },
                onProductClick = { productId -> navController.navigate("${Routes.PRODUCT_DETAIL}/$productId") },
                onRegisterClick = { navController.navigate(Routes.REGISTER) }
            )
        }
        composable(Routes.ADD_PRODUCT) {
            AddProductScreen(onProductCreated = { navController.popBackStack() })
        }
        composable("${Routes.PRODUCT_DETAIL}/{productId}") {
            ProductDetailScreen(
                onNavigateBack = { navController.popBackStack() }
            )
        }
        composable(Routes.REGISTER) {
            RegisterScreen(
                onRegisterSuccess = { navController.popBackStack() }, // Vuelve al Login
                onNavigateBack = { navController.popBackStack() } // También para la flecha de atrás
            )
        }
    }
}
===== ./app/src/main/java/com/mobileshop/navigation/SplashScreen.kt =====
package com.mobileshop.navigation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController

@Composable
fun SplashScreen(
    navController: NavController,
    viewModel: SplashViewModel = hiltViewModel()
) {
    val authState by viewModel.authState.collectAsState()

    // Este efecto se ejecuta cuando 'authState' cambia
    LaunchedEffect(authState) {
        when (authState) {
            AuthState.Authenticated -> {
                navController.navigate(Routes.PRODUCT_LIST) {
                    // Limpiamos la pila para que el usuario no pueda volver al splash
                    popUpTo(Routes.SPLASH) { inclusive = true }
                }
            }
            AuthState.Unauthenticated -> {
                navController.navigate(Routes.LOGIN) {
                    popUpTo(Routes.SPLASH) { inclusive = true }
                }
            }
            AuthState.Loading -> { /* No hacemos nada, esperamos a que termine la carga */ }
        }
    }

    // La UI es simplemente un indicador de carga centrado
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        CircularProgressIndicator()
    }
}
===== ./app/src/main/java/com/mobileshop/navigation/SplashViewModel.kt =====
package com.mobileshop.navigation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.mobileshop.core.data.local.TokenManager
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class SplashViewModel @Inject constructor(
    private val tokenManager: TokenManager
) : ViewModel() {

    private val _authState = MutableStateFlow<AuthState>(AuthState.Loading)
    val authState = _authState.asStateFlow()

    init {
        checkToken()
    }

    private fun checkToken() {
        viewModelScope.launch {
            delay(1500) // Un pequeño delay estético para que se vea tu logo
            val token = tokenManager.getAccessToken()
            if (token.isNullOrEmpty()) {
                _authState.value = AuthState.Unauthenticated
            } else {
                _authState.value = AuthState.Authenticated
            }
        }
    }
}

// El estado se simplifica, ya no necesita la parte biométrica
sealed class AuthState {
    object Loading : AuthState()
    object Authenticated : AuthState()
    object Unauthenticated : AuthState()
}
===== ./app/src/main/java/com/mobileshop/ui/theme/Color.kt =====
package com.mobileshop.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)
===== ./app/src/main/java/com/mobileshop/ui/theme/Theme.kt =====
package com.mobileshop.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun MobileShopTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}
===== ./app/src/main/java/com/mobileshop/ui/theme/Type.kt =====
package com.mobileshop.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)
===== ./build.gradle.kts =====
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id("com.google.devtools.ksp") version "2.0.21-1.0.27" apply false
    id("com.android.application") version libs.versions.agp.get() apply false
    id("org.jetbrains.kotlin.android") version libs.versions.kotlin.get() apply false
    id("com.google.dagger.hilt.android") version libs.versions.hiltAndroid.get() apply false
    alias(libs.plugins.kotlin.compose) apply false
}
===== ./gradle/libs.versions.toml =====
[versions]
agp = "8.12.0"
coilCompose = "2.7.0"
kotlin = "2.0.21"
coreKtx = "1.16.0"
junit = "4.13.2"
junitVersion = "1.3.0"
espressoCore = "3.7.0"
lifecycleRuntimeKtx = "2.9.2"
activityCompose = "1.10.1"
composeBom = "2025.07.00"
appcompat = "1.7.1"
hiltAndroid = "2.57"
hiltAndroidCompiler = "2.57"
hiltNavigationCompose = "1.2.0"
retrofit = "3.0.0"
converterGson = "3.0.0"
datastorePreferences = "1.1.7"
mediationTestSuite = "3.0.0"
runtimeLivedata = "1.8.3"
navigationCommon = "2.9.0"
navigationComposeJvmstubs = "2.9.3"
composeCompiler = "2.0.21"
materialIconsExtended = "1.7.8"
roomRuntime = "2.7.2"
roomCompiler = "2.7.2"
roomKtx = "2.7.2"
workRuntime = "2.10.3"
hiltCommon = "1.2.0"
biometricKtx = "1.2.0-alpha05"
hiltWork = "1.2.0"
biometric = "1.4.0-alpha04"
hiltCompiler = "1.2.0"
securityCryptoKtx = "1.1.0"
securityCrypto = "1.1.0"           # <–– Añadido para el plugin de Compose Compiler

[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
coil-compose = { module = "io.coil-kt:coil-compose", version = "2.5.0" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version = "1.3.0" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version = "3.7.0" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest", version = "1.8.3" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
androidx-hilt-navigation-compose = { group = "androidx.hilt", name = "hilt-navigation-compose", version.ref = "hiltNavigationCompose" }
androidx-appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
hilt-android = { group = "com.google.dagger", name = "hilt-android", version = "2.57" }
hilt-android-compiler = { group = "com.google.dagger", name = "hilt-android-compiler", version.ref = "hiltAndroidCompiler" }
retrofit = { group = "com.squareup.retrofit2", name = "retrofit", version.ref = "retrofit" }
converter-gson = { group = "com.squareup.retrofit2", name = "converter-gson", version.ref = "converterGson" }
logging-interceptor = { group = "com.squareup.okhttp3", name = "logging-interceptor", version = "4.12.0" }
androidx-datastore-preferences = { group = "androidx.datastore", name = "datastore-preferences", version.ref = "datastorePreferences" }
mediation-test-suite = { group = "com.google.android.ads", name = "mediation-test-suite", version.ref = "mediationTestSuite" }
androidx-runtime-livedata = { group = "androidx.compose.runtime", name = "runtime-livedata", version.ref = "runtimeLivedata" }
androidx-navigation-common = { group = "androidx.navigation", name = "navigation-common", version.ref = "navigationCommon" }
androidx-navigation-compose = { group = "androidx.navigation", name = "navigation-compose", version.ref = "navigationComposeJvmstubs" }
androidx-material-icons-extended = { group = "androidx.compose.material", name = "material-icons-extended", version.ref = "materialIconsExtended" }
androidx-room-runtime = { group = "androidx.room", name = "room-runtime", version.ref = "roomRuntime" }
androidx-room-compiler = { group = "androidx.room", name = "room-compiler", version.ref = "roomCompiler" }
androidx-room-ktx = { group = "androidx.room", name = "room-ktx", version.ref = "roomKtx" }
androidx-work-runtime = { group = "androidx.work", name = "work-runtime", version = "2.10.2" }
androidx-hilt-common = { group = "androidx.hilt", name = "hilt-common", version.ref = "hiltCommon" }
androidx-biometric-ktx = { group = "androidx.biometric", name = "biometric-ktx", version.ref = "biometricKtx" }
androidx-hilt-work = { group = "androidx.hilt", name = "hilt-work", version.ref = "hiltWork" }
androidx-biometric = { group = "androidx.biometric", name = "biometric", version.ref = "biometric" }
androidx-hilt-compiler = { group = "androidx.hilt", name = "hilt-compiler", version.ref = "hiltCompiler" }
androidx-security-crypto-ktx = { group = "androidx.security", name = "security-crypto-ktx", version = "1.1.0-beta01" }
androidx-security-crypto = { group = "androidx.security", name = "security-crypto", version = "1.1.0-beta01" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
kotlin-compose = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "composeCompiler" }
hilt = { id = "com.google.dagger.hilt.android", version.ref = "hiltAndroid" }
kapt = { id = "org.jetbrains.kotlin.kapt", version.ref = "kotlin" }